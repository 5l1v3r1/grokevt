#!/usr/bin/env python

# This script will take an input Windows Event Log and parse it to
# stdout as ASCII text.  This is particularly useful for forensics being
# conducted on an evidence drive under *NIX.
#
# The original code was written in PHP by Jamie French.  It has been
# since ported to Python and extended by Timothy Morgan.
#
# For the original PHP version, please see:
#http://www.whitehats.ca/main/members/Malik/malik_eventlogs/malik_eventlogs.html
# 
# Copyright (C) 2005 Timothy D. Morgan
# Copyright (C) 2004 Jamie French
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation version 2 of the
# License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# $Id$


import sys
import string
import os
import struct
import re
import time
import csv
from grokevt import *


# XXX: This mapping may not be entirely accurate.  In particular,
#      FailureAudit and SuccessAudit were educated guesses.  The others
#      appear to be correct.
eventTypeEnum = ('FailureAudit',
                 'Error',
                 'Warning',
                 'SuccessAudit',
                 'Information')

def usage():
    print "USAGE:"
    print "  %s <DATABASE_DIR> [<LOG_TYPE>]"\
          % os.path.basename(sys.argv[0])
    print
    print "This program parses a windows event log and prints a CSV"
    print "version of the log to stdout.  Please see the man page for"
    print "more information."


def guessRecordType(f):
    cur_pos = f.tell()
    ret_val = 'unknown'

    (size1,) = struct.unpack('<I', f.read(4))
    if(size1 >= 28):
        f.seek(size1-8,1)
        (size2,) = struct.unpack('<I', f.read(4))
        if(size2 == size1):
            f.seek(4-size1,1)
            if(size1 == 0x30):
                magic = f.read(4)
                if(magic == "\x4c\x66\x4c\x65"):
                    ret_val = 'header'
                
            elif(size1 == 0x28):
                magic = f.read(16)
                if(magic == ("\x11\x11\x11\x11\x22\x22\x22\x22"
                             +"\x33\x33\x33\x33\x44\x44\x44\x44")):
                    ret_val = 'cursor'
                
            else:
                magic = f.read(4)
                if(magic == "\x4c\x66\x4c\x65"):
                    ret_val = 'log'
    
    f.seek(cur_pos)
    return ret_val


def getHeaderRecord(f):
    fmt = '<IIIIIIIIIIII'
    fmt_len = struct.calcsize(fixed_fmt)
    #XXX: check for read failure
    raw_rec = f.read(fixed_fmt)
    
    (size1,lfle,unknown1,unknown2,
     first_off,next_off,next_num,first_num,
     file_size,flags,retention,size2) = struct.unpack(fmt, raw_rec)

    flag_dirty =   flags & 0x1
    flag_wrapped = flags & 0x2
    flag_logfull = flags & 0x4
    flag_primary = flags & 0x8

    ret_val = {'first_off':first_off, 'first_num':first_num,
               'next_off':next_off, 'next_num':next_num,
               'file_size':file_size, 'retention':retention,
               'flag_dirty':flag_dirty, 'flag_wrapped':flag_wrapped,
               'flag_logfull':flag_logfull, 'flag_primary':flag_primary}
    return ret_val


def getCursorRecord(f):
    fmt = '<IIIIIIIIII'
    fmt_len = struct.calcsize(fixed_fmt)
    #XXX: check for read failure
    raw_rec = f.read(fixed_fmt)
    
    (size1,magic1,magic2,magic3,magic4,
     first_off,next_off,next_num,first_num,
     size2) = struct.unpack(fmt, raw_rec)

    ret_val = {'first_off':first_off, 'first_num':first_num,
               'next_off':next_off, 'next_num':next_num}
    return ret_val


def getLogRecord(f):
    #XXX: check for read failure
    size_str = f.read(4)
    if len(size_str) < 4:
        return None
    (size,) = struct.unpack('<I', size_str)
    
    fixed_fmt = '<IIIIHHHHHHIIIIII'
    fixed_fmt_len = struct.calcsize(fixed_fmt)

    #XXX: check for read failure
    rec_str = f.read(size-4)
    if len(rec_str) < fixed_fmt_len:
        return [-1,'','','',
                os.path.basename(sys.argv[0]),
                '','-1','','','',
                "There was an error processing this event."\
                + "Binary record is not long enough.",
                '','']
    
    variable_str_len = len(rec_str) - fixed_fmt_len
    (lfle,msg_num,
     date_created,date_written,
     event_id,event_rva_offset,
     event_type,strcount,
     category,unknown,
     closing_record_number,string_offset,
     sid_len,sid_offset,
     data_len,data_offset,
     variable_str) = struct.unpack("%s%ds" % (fixed_fmt, variable_str_len),
                                   rec_str)
    # Grab source and computer fields
    # XXX: Need to properly handle unicode.
    source_end = variable_str.find('\x00\x00')
    source = variable_str[:source_end].replace('\x00', '')
    tmp = variable_str[source_end+2:]
    computer_end = tmp.find('\x00\x00')
    computer = tmp[:computer_end].replace('\x00', '')
    tmp = None
    
    # Grab SID
    sid = 'N/A'
    if sid_len > 0:
        sid_str = rec_str[sid_offset-4:sid_offset+sid_len-4]
        sid = binSIDtoASCII(sid_str)

    # Grab template variables
    strs = []
    if string_offset > 0:
        strs = rec_str[string_offset-4:data_offset-4].split('\x00\x00')
        # XXX: Need to properly handle unicode.
        tmp_strs = []
        for s in strs:
            tmp_strs.append(s.replace('\x00', ''))
        strs = tmp_strs
        tmp_strs = None

    # Grab binary data chunk
    data = ''
    if data_len > 0:
        data = rec_str[data_offset-4:data_offset+data_len-4]
    
    # Retrieve and process message template
    event_rva = "%.8X"%(long(event_rva_offset)<<16|event_id)
    message_template = msg_repo.getMessageTemplate(source, event_rva)
    message = ''
    if message_template:
        message = formatMessage(message_template, strs)
    else:
        sys.stderr.write("WARNING: Couldn't find message"\
                         +" template for event record #%d\n" % msg_num)

    # Format fields and return
    return [msg_num,
            eventTypeEnum[event_type],
            time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(date_created)),
            time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(date_written)),
            source,
            category,
            event_id,
            "0x%s" % event_rva,
            sid,
            computer,
            message,
            '|'.join(strs).strip('|'),
            data]


header_rec = ("MSG_NUM","EVENT_TYPE",
              "DATE_CREATED","DATE_WRITTEN",
              "SOURCE","CATEGORY",
              "EVENT_ID","EVENT_RVA",
              "USER","COMPUTER",
              "MESSAGE","STRINGS","DATA")

if ((len(sys.argv) != 3) and (len(sys.argv) != 2))\
       or (sys.argv[1] == '-h') or (sys.argv[1] == '--help'):
    usage()
    sys.exit(1)

DB_PATH=sys.argv[1]
if len(sys.argv) == 2:
    try:
        logs = os.listdir("%s/services" % DB_PATH)
        for l in logs:
            print l
    except Exception, inst:
        print inst
        print "ERROR: Could not list services directory."
        print "       Did you run grokevt-builddb first?"
        sys.exit(2)
    sys.exit(0)


try:
    LOG=sys.argv[2]
    msg_repo = messageRepository(DB_PATH, LOG)
except Exception, inst:
    print inst
    print "ERROR: Could not read message repository."
    print "       Did you run grokevt-builddb first?"
    sys.exit(2)


evt_file = "%s/logs/%s.evt" % (DB_PATH, LOG)
try:
    evt_handle = file(evt_file, "r")
except Exception, inst:
    print inst
    print "ERROR: Could not open log file."
    print "       Did grokevt-builddb finish without errors?"
    sys.exit(2)

csvwriter = csv.writer(sys.stdout)
csvwriter.writerow(header_rec)
rec = getLogRecord(evt_handle)
while rec:
    rec = map(quoteBinaryInString, rec)
    csvwriter.writerow(rec)
    rec = getLogRecord(evt_handle)
