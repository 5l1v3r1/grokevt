#!/usr/bin/python

# This script will take an input Windows Event Log
# and parse it to stdout as ASCII text.
# Purpose: Useful for forensics being conducted on an
# evidence drive (specifically under *NIX).
#
# The original code was written in PHP by Jamie French.  It has
# been since ported to Python and extended by Timothy Morgan.
#
# For the original PHP version, please see:
#http://www.whitehats.ca/main/members/Malik/malik_eventlogs/malik_eventlogs.html
# 
# Copyright (C) 2005 Timothy Morgan
# Copyright (C) 2004 Jamie French
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation version 2 of the
# License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

import sys
import string
import os
import struct
import anydbm
import re
import time
import csv


def usage():
    print "USAGE:"
    print "  %s <DATABASE_DIR> [<LOG_TYPE>]" % sys.argv[0]
    print
    print "This program parses a windoze event log and prints a text version"
    print "of the log to stdout."
    print 
    print "DATABASE_DIR The location of the directory tree that was previously"
    print "             created by build-databases."
    print
    print "LOG_TYPE     The (case-sensitive) windoze log type.  Most commonly,"
    print "             one of:"
    print "               Application"
    print "               Security"
    print "               System"
    print "             If not specified, a list of available log types is"
    print "             printed."
    print
    print
    print "CREDITS"
    print
    print "Originally written by Jamie French.  Converted to Python"
    print "and extended by Timothy Morgan."
    print "Copyright (C) 2005 Timothy Morgan"
    print "Copyright (C) 2004 Jamie French"
    print
    print "This program is free software; you can redistribute it and/or"
    print "modify it under the terms of the GNU General Public License"
    print "as published by the Free Software Foundation version 2 of the"
    print "License."
    print
    print "This program is distributed in the hope that it will be useful,"
    print "but WITHOUT ANY WARRANTY; without even the implied warranty of"
    print "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"
    print "GNU General Public License for more details."

# Reference:
#  http://blogs.msdn.com/oldnewthing/archive/2004/03/15/89753.aspx
def binSIDtoASCII(rev,dashes,b0,b1,b2,b3,b4,b5,
                  rest):
   auth = (b0<<40) | (b1<<32) | (b2<<24) | (b3<<16) | (b4<<8) | b5
   result = "S-%d-%d" % (rev, auth)
   for i in range(0,dashes):
       if(i < len(rest)):
           result = "%s-%s" % (result, rest[i])

   return result

# Reference:
#  http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/wsprintf.asp
#
# returns a formatted string.
def wsprintf(fmt, vars):
    # Python's formatting is very close to wsprintf's.  Just a few types need
    # to be converted.  This isn't 100% compliant with the spec.

    optionals = r'(-?#?0?[0-9]*[.]?[0-9]*)'

    # S,ls,lS,hs,hS => s
    py_fmt = re.sub('%'+optionals+'[lh]{0,1}[sS]',
                    r'%\1s', fmt)
    
    # lu,li,ld,hu,hi,hd => d
    py_fmt = re.sub('%'+optionals+'[lh][uid]',
                    r'%\1d', py_fmt)

    # lc,lC,C => c
    py_fmt = re.sub('%'+optionals+'l{0,1}[cC]',
                    r'%\1c', py_fmt)

    # lx => x; lX => X
    py_fmt = re.sub('%'+optionals+'l([xX])',
                    r'%\1\2', py_fmt)

    # p => d
    py_fmt = re.sub('%'+optionals+'p',
                    r'%\1d', py_fmt)

    return (py_fmt % vars)


# Reference:
#  http://msdn.microsoft.com/library/en-us/debug/base/formatmessage.asp
def formatMessage(fmt, vars):
   # states:
   # 0: normal text
   # 1: in escape sequence
   # 3: in format string
   state=0
   ret_val=''
   arg_num=''
   arg_index = None
   for c in fmt:
      if state == 0:
         if c == '%':
            state=1
         else:
            ret_val += c
      elif state == 1:
         if len(arg_num) == 0:
            if ord(c) > 0x2f and ord(c) < 0x3a:
               arg_num = c
            elif c in ('%', ' ', '.', '!'):
               ret_val += c
               state = 0
            elif c == 'n':
               ret_val += '\x0a'
               state = 0
         elif len(arg_num) == 1:
            if ord(c) > 0x2f and ord(c) < 0x3a:
               arg_index = int(arg_num + c) - 1
            else:
               arg_index = int(arg_num) - 1

            if c == '!':
               state = 3
            else:
               if arg_index < len(vars):
                  if c == '%':
                     ret_val += "%s" % vars[arg_index]
                     state = 1
                     arg_num = ''
                  else:
                     ret_val += "%s%s" % (vars[arg_index], c)
                     state = 0
                     arg_num = ''
               else:
                  # arg_num not in vars
                  if c == '%':
                     ret_val += "%%%s" % arg_num
                     state = 2
                     arg_num = ''
                  else:
                     ret_val += "%%%s%s" % (arg_num, c)
                     state = 0
                     arg_num = ''
      # TODO: implement extended format string
      elif state == 3:
         if c == '!':
            state = 1

   return ret_val


class messageRepository:
   svc_dbs = {}
   msg_dbs = {}
   def __init__(self, topdir, log):
      msg_dir = "%s/messages" % topdir
      dbs = os.listdir(msg_dir)
      for db in dbs:
         db_file = "%s/%s" % (msg_dir,db)
         self.msg_dbs[db] = anydbm.open(db_file, "r", 0644)

      log_dir = "%s/services" % topdir
      for t in ("category", "event", "parameter"):
          db_file = "%s/%s/%s.db" % (log_dir, log, t)
          self.svc_dbs[t] = anydbm.open(db_file, "r")
   
         
   def getMessageTemplate(self, service, rva):
       ret_val = None
       mdbs = self.svc_dbs["event"].get(service.lower(), None)
       if mdbs:
           for mdb in mdbs.split(':'):
               ret_val = self.msg_dbs[mdb].get(rva, None)
               if ret_val:
                   break
      
       return ret_val


if (len(sys.argv) != 3) or (sys.argv[1] == '-h') or (sys.argv[1] == '--help'):
    usage()
    sys.exit(1)

DB_PATH=sys.argv[1]
if len(sys.argv) == 2:
    logs = os.listdir("%s/services" % DB_PATH)
    for l in logs:
        print l
    sys.exit(0)



LOG=sys.argv[2]
msg_repo = messageRepository(DB_PATH, LOG)

evt_file = "%s/logs/%s.evt" % (DB_PATH, LOG)
evt_handle = file(evt_file, "r")
#XXX: this could be more efficient
entire_log=evt_handle.read()
records=entire_log.split('\x4c\x66\x4c\x65')
entire_log=None

thecount=len(records)
csvwriter = csv.writer(sys.stdout)
csvwriter.writerow(("MSG_NUM","DATE_CREATED","DATE_WRITTEN","EVENT_RVA",
                    "EVENT_ID","EVENT_TYPE","STR_COUNT",
                    "CATEGORY","SID",
                    "UNKNOWN_A","UNKNOWN_B","UNKNOWN_C","UNKNOWN_D",
                    "SOURCE","SYSTEM","MESSAGES..."))

for rec in records:
    # Default values
    msgnum=-1
    date_created=0
    date_written=0
    event_rva_offset=0
    eventid=0
    eventtype=''
    strcount=''
    category=''
    (sid_rev,sid_dashes,
     sid_b0,sid_b1,sid_b2,sid_b3,sid_b4,sid_b5)=(0,0,0,0,0,0,0,0)
    rest=[]
    unknown_a=''
    unknown_b=''
    unknown_c=''
    unknown_d=''
    msgstr_raw=''
    source=''
    computer=''
    messages=[]
    event_rva=''

    #print "length: %d" % len(rec)
    if len(rec) < 45:
        source="evt_parser.py";
        messages=["There was an error processing this event."\
                  +"  Binary log not long enough."]
    else:
        # Field byte lengths: 4,4,4,2,1,1,1,2,2,8,4,4,4,4,var
        unpack_fmt = '<IIIHHBHHBBBBBBBBIIII'
        msg_len = len(rec) - struct.calcsize(unpack_fmt)
        (msgnum,date_created,
         date_written,eventid,
         event_rva_offset,
         eventtype,strcount,
         category,
         sid_rev,sid_dashes,sid_b0,sid_b1,sid_b2,sid_b3,sid_b4,sid_b5,
         unknown_a,unknown_b,
         unknown_c,unknown_d,
         msgstr_raw) = struct.unpack("%s%ds" % (unpack_fmt, msg_len), rec)
        event_rva = "%X"%(event_rva_offset<<16|eventid)
        
        #TODO: Properly handle unicode
        sid_fmt='<BBBBBBBB'
        msgstr_raw = msgstr_raw.lstrip('\x00')
        next = msgstr_raw.find('\x00\x00')
        i = 0
        while next > -1:
            if i == 0:
                source = msgstr_raw[0:next].replace('\x00', '')
            elif i == 1:
                computer = msgstr_raw[0:next].replace('\x00', '')
            else:
                messages.append(msgstr_raw[0:next])
            msgstr_raw = msgstr_raw[(next+2):]
            i += 1
            next = msgstr_raw.find('\x00\x00')
        
        for i in range(0,len(messages)):
            messages[i] = messages[i].replace('\x00', '')

    row = [msgnum,
           time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(date_created)),
           time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(date_written)),
           event_rva, eventid,
           eventtype,strcount,
           category,
           binSIDtoASCII(sid_rev,sid_dashes,
                         sid_b0,sid_b1,sid_b2,sid_b3,sid_b4,sid_b5, []),
           unknown_a, unknown_b,
           unknown_c, unknown_d,
           source, computer]
    message_template = msg_repo.getMessageTemplate(source, event_rva)
    if message_template:
       m = formatMessage(message_template, messages)
       row.append(m)
    else:
       sys.stderr.write("WARNING: Couldn't find message"\
                        +" template for message %d\n" % msgnum)
       row.extend(messages)

    csvwriter.writerow(row)

    #DEBUG
    #print "msgnum: %X\n" % (msgnum)
    #print "date_created: %X\n" % (date_created)
    #print "date_written: %X\n" % (date_written)
    #print "eventid: %X\n" % (eventid)
    #print "category: %X\n" % (category)
    #print "unknown1: %X\n" % (unknown1)
    #print "eventtype: %X\n" % (eventtype)
    #print "strcount: %X\n" % (strcount)
    #print "sid: %d,%d,%d,%d,%d,%d,%d,%d" % (sid_rev,sid_dashes,
    #                                        sid_b0,sid_b1,sid_b2,sid_b3,sid_b4,sid_b5)
    #print "unknown_d: %X\n" % (unknown_d)
        #print "unknown_c: %X\n" % (unknown_c)
        #print "unknown_b: %X\n" % (unknown_b)
        #print "unknown_a: %X\n" % (unknown_a)
        #print "msgstr: %s\n" % (msgstr)


